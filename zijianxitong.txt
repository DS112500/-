#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <pthread.h>
#include <time.h>
#include <errno.h>
#include <sys/select.h>

// 配置参数
#define BUFFER_SIZE 2048
#define MAX_FRAME_LENGTH 512
#define GPS_UART_DEVICE "/dev/ttyS2"     // ESP8266连接的串口
#define BLE_UART_DEVICE "/dev/ttyS1"     // 蓝牙信标连接的串口
#define MAIN_UART_DEVICE "/dev/ttyS3"    // 下位机连接的串口
#define SERVER_IP "115.28.209.116"
#define SERVER_PORT 9801
#define DEVICE_ID "7c94f3672990e521"
#define DATA_TIMEOUT 100                  // 数据超时时间(秒)

// 数据类型定义
typedef enum {
    DATA_TYPE_BLE,
    DATA_TYPE_GPS,
    DATA_TYPE_HEALTH,
    DATA_TYPE_FALL,
    DATA_TYPE_UNKNOWN,
    DATA_TYPE_RANGE_CHECK                // 新增：范围检测类型
} DataType;

// 蓝牙信标MAC地址定义
const char *BEACON_MAC_1 = "609866C63690";
const char *BEACON_MAC_2 = "609866C636E8";
const char *BEACON_MAC_3 = "609866C63BD5";


// 数据帧结构
typedef struct {
    DataType type;
    time_t timestamp;
    union {
        struct {
            char mac[20];
            int rssi;
            int command;  // 1, 2, 3
        } ble;
        struct {
            double latitude;
            double longitude;
        } gps;
        struct {
            int heartRate;
            int spo2;
        } health;
        struct {
            char fall[10];
        } fall;
        struct {
            char outrange[30];
        } range;
    } data;
} DataFrame;

// 全局变量
int gps_fd = -1, ble_fd = -1, main_fd = -1;
int esp8266_connected = 0;
pthread_mutex_t send_mutex = PTHREAD_MUTEX_INITIALIZER;
time_t last_data_time;  // 最后一次接收数据的时间
pthread_mutex_t time_mutex = PTHREAD_MUTEX_INITIALIZER;  // 保护时间变量的互斥锁
int timeout_alert_sent = 0;

// 函数声明
int init_uart(const char *device, speed_t baudrate);
int connect_to_cloud();
int send_to_cloud(const char *data);
int send_to_main(const char *data);
void process_ble_data(const char *buffer);
void process_gps_data(const char *buffer);
void process_health_data(const char *buffer);
void process_fall_data(const char *buffer);
double extract_lat(const char *buffer);
double extract_lon(const char *buffer);
int extract_heart_rate(const char *buffer);
int extract_spo2(const char *buffer);
int is_fall_detection(const char *buffer);
void construct_beacon_command(const char *mac, int rssi, char *command);
void construct_gps_json(double lat, double lon, char *json);
void construct_health_json(int heartRate, int spo2, char *json);
void construct_fall_json(char *json);
void construct_range_json(char *json);  // 新增：构建范围检测JSON
void *timeout_monitor(void *arg);  // 新增：超时监控线程

// 初始化串口
int init_uart(const char *device, speed_t baudrate) {
    int fd = open(device, O_RDWR | O_NOCTTY | O_NDELAY);
    if (fd < 0) {
        perror("无法打开串口");
        return -1;
    }

    struct termios options;
    tcgetattr(fd, &options);
    cfsetispeed(&options, baudrate);
    cfsetospeed(&options, baudrate);

    options.c_cflag |= (CLOCAL | CREAD);
    options.c_cflag &= ~PARENB;
    options.c_cflag &= ~CSTOPB;
    options.c_cflag &= ~CSIZE;
    options.c_cflag |= CS8;
    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
    options.c_oflag &= ~OPOST;

    options.c_cc[VMIN] = 0;
    options.c_cc[VTIME] = 10;  // 1秒超时

    tcsetattr(fd, TCSANOW, &options);
    tcflush(fd, TCIOFLUSH);

    return fd;
}

void reconnect()
{
    printf("正在重连");
    char command[128];
    // 连接WiFi
    sprintf(command, "AT+CWJAP=\"vivo S18\",\"yxn20060824\"\r\n");
    write(gps_fd, command, strlen(command));
    sleep(10);  // 等待WiFi连接

    // 连接TCP服务器
    sprintf(command, "AT+CIPSTART=\"TCP\",\"%s\",%d\r\n", SERVER_IP, SERVER_PORT);
    write(gps_fd, command, strlen(command));
    sleep(2);

    // 检查连接状态
    char buffer[256];
    memset(buffer, 0, sizeof(buffer));
    read(gps_fd, buffer, sizeof(buffer) - 1);

    if (strstr(buffer, "CONNECT")) {
        esp8266_connected = 1;
        printf("已连接到云平台\n");
    } else {
        printf("连接云平台失败\n");

    }
}

// 连接到云平台
int connect_to_cloud() {
    printf("正在连接到云平台...\n");

    // 发送AT指令初始化ESP8266
    char command[128];

    // 重置ESP8266
    sprintf(command, "AT+RST\r\n");
    write(gps_fd, command, strlen(command));
    sleep(1);

    // 设置为STA模式
    sprintf(command, "AT+CWMODE=1\r\n");
    write(gps_fd, command, strlen(command));
    sleep(1);

    // 连接WiFi
    sprintf(command, "AT+CWJAP=\"vivo S18\",\"yxn20060824\"\r\n");
    write(gps_fd, command, strlen(command));
    sleep(1);  // 等待WiFi连接

    // 连接TCP服务器
    sprintf(command, "AT+CIPSTART=\"TCP\",\"%s\",%d\r\n", SERVER_IP, SERVER_PORT);
    write(gps_fd, command, strlen(command));
    sleep(1);

    // 检查连接状态
    char buffer[256];
    memset(buffer, 0, sizeof(buffer));
    read(gps_fd, buffer, sizeof(buffer) - 1);

    if (strstr(buffer, "CONNECT")) {
        esp8266_connected = 1;
        printf("已连接到云平台\n");
        return 0;
    } else {
        printf("连接云平台失败\n");
        return -1;
    }
}

// 发送数据到云平台
int send_to_cloud(const char *data) {
    pthread_mutex_lock(&send_mutex);
    
    int retries = 3; // 设置最大重试次数
    while (retries > 0) {
        if (!esp8266_connected) {
            printf("ESP8266未连接，尝试重连...\n");
            if (connect_to_cloud() != 0) {
                printf("重连失败，剩余重试次数: %d\n", retries - 1);
                retries--;
                sleep(1); // 等待一段时间再重试
                continue;
            }
        }
        
        char command[128];
        int length = strlen(data);

        // 设置发送长度
        sprintf(command, "AT+CIPSEND=%d\r\n", length);
        write(gps_fd, command, strlen(command));
        sleep(1);

        // 发送数据
        write(gps_fd, data, strlen(data));
        sleep(1);

        // 读取响应
        char buffer[256];
        memset(buffer, 0, sizeof(buffer));
        read(gps_fd, buffer, sizeof(buffer) - 1);

        if (strstr(buffer, "SEND OK")) {
            printf("数据已发送到云平台: %s\n", data);
            pthread_mutex_unlock(&send_mutex);
            return 0;
        } else {
            printf("发送到云平台失败，尝试重连\n");
            esp8266_connected = 0;
            retries--;
        }
    }
    
    printf("发送到云平台失败，已达到最大重试次数\n");
    pthread_mutex_unlock(&send_mutex);
    return -1;
}

// 发送数据到下位机
int send_to_main(const char *data) {
    if (main_fd < 0) return -1;

    int bytes_written = write(main_fd, data, strlen(data));
    if (bytes_written > 0) {
        printf("已发送到下位机: %s\n", data);
        return 0;
    } else {
        perror("发送到下位机失败");
        return -1;
    }
}

// 处理蓝牙信标数据
void process_ble_data(const char *buffer) {
    // 提取MAC地址
    const char *mac_start = strstr(buffer, "Mac:");
    if (!mac_start) return;

    mac_start += 4;  // 跳过"Mac:"

    const char *mac_end = strchr(mac_start, ' ');
    if (!mac_end) return;

    char mac[20];
    strncpy(mac, mac_start, mac_end - mac_start);
    mac[mac_end - mac_start] = '\0';

    // 提取RSSI
    const char *rssi_start = strstr(mac_end, "Rssi:");
    if (!rssi_start) return;

    rssi_start += 5;  // 跳过"Rssi:"

    int rssi = atoi(rssi_start);

    // 构建并发送命令
    char command[2];
    construct_beacon_command(mac, rssi, command);

    if (command[0] != '0') {
        send_to_main(command);
    }
}

// 处理GPS数据
void process_gps_data(const char *buffer) {
    double lat = extract_lat(buffer);
    double lon = extract_lon(buffer);
    
    if(lat > 0 && lon > 0) {
        // 更新最后接收数据时间
        pthread_mutex_lock(&time_mutex);
        last_data_time = time(NULL);
        pthread_mutex_unlock(&time_mutex);
        
        // 构建并发送JSON
        char json[256];
        construct_gps_json(lat, lon, json);
        send_to_cloud(json);
    }
}

// 处理健康数据
void process_health_data(const char *buffer) {
    int heartRate = extract_heart_rate(buffer);
    int spo2 = extract_spo2(buffer);

    if (heartRate > 0 && spo2 > 0) {
        // 更新最后接收数据时间
        pthread_mutex_lock(&time_mutex);
        last_data_time = time(NULL);
        pthread_mutex_unlock(&time_mutex);
        
        // 构建并发送JSON
        char json[256];
        construct_health_json(heartRate, spo2, json);
        send_to_cloud(json);
    }
}

// 处理摔倒检测数据
void process_fall_data(const char *buffer) {
    if (is_fall_detection(buffer)) {
        // 更新最后接收数据时间
        pthread_mutex_lock(&time_mutex);
        last_data_time = time(NULL);
        pthread_mutex_unlock(&time_mutex);
        
        // 构建并发送JSON
        char json[256];
        construct_fall_json(json);
        send_to_cloud(json);
    }
}

// 提取经纬度
double extract_lat(const char *buffer) {
    // 找到纬度起始位置
    const char *lat_str = strstr(buffer,"La:");
    if (!lat_str) return 0;
    lat_str += strlen("La:");
    // 转换为double并截取后两位小数
    return atof(lat_str);
}

double extract_lon(const char *buffer) {
    const char *lon_str = strstr(buffer,"Lo:");
    if(!lon_str) return 0;
    lon_str += strlen("Lo:");
    return atof(lon_str);
}

// 提取心率
int extract_heart_rate(const char *buffer) {
    const char *hr_start = strstr(buffer, "Heart Rate:");
    if (!hr_start) return 0;

    hr_start += strlen("Heart Rate:");

    return atoi(hr_start);
}

// 提取血氧（新增实现）
int extract_spo2(const char *buffer) {
    const char *spo2_start = strstr(buffer, "SpO2:");
    if (!spo2_start) return 0;

    spo2_start += strlen("SpO2:");

    return atoi(spo2_start);
}

// 判断是否为摔倒检测
int is_fall_detection(const char *buffer) {
    return strstr(buffer, "FALL") != NULL;
}

// 构建蓝牙信标命令
void construct_beacon_command(const char *mac, int rssi, char *command) {
    command[0] = '0';  // 默认不发送

    // 判断MAC地址并检查RSSI范围
    if (strcmp(mac, BEACON_MAC_1) == 0 && rssi >= -30 && rssi <= -20) {
        command[0] = '1';
    } else if (strcmp(mac, BEACON_MAC_2) == 0 && rssi >= -30 && rssi <= -20) {
        command[0] = '2';
    } else if (strcmp(mac, BEACON_MAC_3) == 0 && rssi >= -30 && rssi <= -20) {
        command[0] = '3';
    }

    command[1] = '\0';
}

// 构建GPS JSON
void construct_gps_json(double lat, double lon, char *json) {
    sprintf(json, "{\"sign\":\"%s\",\"type\":1,\"data\":{\"location\":{\"latitude\":%.2f,\"longitude\":%.2f}}}",
            DEVICE_ID, lat, lon);
}

// 构建健康数据JSON
void construct_health_json(int heartRate, int spo2, char *json) {
    sprintf(json, "{\"sign\":\"%s\",\"type\":1,\"data\":{\"health\":{\"HeartRate\":%d,\"SpO2\":%d}}}",
            DEVICE_ID, heartRate, spo2);
}

// 构建摔倒检测JSON
void construct_fall_json(char *json) {
    sprintf(json, "{\"sign\":\"%s\",\"type\":1,\"data\":{\"fallcheck\":{\"fallcheck\":\"fall\"}}}",
            DEVICE_ID);
}

// 新增：构建范围检测JSON
void construct_range_json(char *json) {
    sprintf(json, "{\"sign\":\"%s\",\"type\":1,\"data\":{\"RangeCheck\":{\"outrange\":\"超出范围或系统故障\"}}}",
            DEVICE_ID);
}

// 超时监控线程
void *timeout_monitor(void *arg) {
    while (1) {
        sleep(1);  // 每秒检查一次
        
        time_t current_time = time(NULL);
        time_t last_time;
        int alert_sent;
        
        // 获取最后接收数据时间和警报状态
        pthread_mutex_lock(&time_mutex);
        last_time = last_data_time;
        alert_sent = timeout_alert_sent;
        pthread_mutex_unlock(&time_mutex);
        
        // 检查是否超时且未发送过警报
        if (difftime(current_time, last_time) > DATA_TIMEOUT && !alert_sent) {
            printf("超过%d秒未收到下位机数据，发送故障信息...\n", DATA_TIMEOUT);
            
            // 先尝试重连，确保连接状态正常
            pthread_mutex_lock(&send_mutex);
            if (!esp8266_connected) {
                printf("ESP8266未连接，在发送超时警报前尝试重连...\n");
                connect_to_cloud();
            }
            pthread_mutex_unlock(&send_mutex);
            
            // 发送超时警报
            char json[256];
            construct_range_json(json);
            int send_result = send_to_cloud(json);
            
            // 如果发送成功，标记为已发送
            if (send_result == 0) {
                pthread_mutex_lock(&time_mutex);
                timeout_alert_sent = 1;
                pthread_mutex_unlock(&time_mutex);
            }
        }
    }
    return NULL;
}

// 主函数
int main() {
    // 初始化串口
    gps_fd = init_uart(GPS_UART_DEVICE, B115200);
    ble_fd = init_uart(BLE_UART_DEVICE, B115200);
    main_fd = init_uart(MAIN_UART_DEVICE, B115200);

    if (gps_fd < 0 || ble_fd < 0 || main_fd < 0) {
        fprintf(stderr, "串口初始化失败\n");
        return -1;
    }

    // 连接到云平台
    connect_to_cloud();

    // 初始化最后接收数据时间为当前时间
    last_data_time = time(NULL);
    timeout_alert_sent = 0;

    // 创建超时监控线程
    pthread_t monitor_thread;
    if (pthread_create(&monitor_thread, NULL, timeout_monitor, NULL) != 0) {
        perror("创建监控线程失败");
        return -1;
    }

    // 设置线程分离，使其在结束时自动释放资源
    pthread_detach(monitor_thread);

    // 数据缓冲区
    char ble_buffer[BUFFER_SIZE] = {0};
    char main_buffer[BUFFER_SIZE] = {0};

    // 主循环
    fd_set readfds;
    int max_fd = (gps_fd > ble_fd) ? gps_fd : ble_fd;
    max_fd = (max_fd > main_fd) ? max_fd : main_fd;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(ble_fd, &readfds);
        FD_SET(main_fd, &readfds);

        // 超时设置为1秒
        struct timeval timeout;
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;

        int activity = select(max_fd + 1, &readfds, NULL, NULL, &timeout);

        if (activity < 0) {
            perror("select错误");
            continue;
        }

        // 处理蓝牙数据
        if (FD_ISSET(ble_fd, &readfds)) {
            char buffer[256];
            memset(buffer, 0, sizeof(buffer));
            int bytes_read = read(ble_fd, buffer, sizeof(buffer) - 1);

            if (bytes_read > 0) {
                // 追加到缓冲区
                strncat(ble_buffer, buffer, sizeof(ble_buffer) - strlen(ble_buffer) - 1);

                // 检查是否有完整的蓝牙数据行
                char *line = strtok(ble_buffer, "\n");
                while (line != NULL) {
                    if (strstr(line, "Mac:") && strstr(line, "Rssi:")) {
                        process_ble_data(line);
                    }
                    line = strtok(NULL, "\n");
                }

                // 清空缓冲区
                memset(ble_buffer, 0, sizeof(ble_buffer));
            }
        }

        // 处理主串口数据
        if (FD_ISSET(main_fd, &readfds)) {
            char buffer[256];
            memset(buffer, 0, sizeof(buffer));
            int bytes_read = read(main_fd, buffer, sizeof(buffer) - 1);

            if (bytes_read > 0) {
                // 追加到缓冲区
                strncat(main_buffer, buffer, sizeof(main_buffer) - strlen(main_buffer) - 1);
                
                // 检查是否有GPS数据
                if (strstr(main_buffer, "La:") && strstr(main_buffer, "Lo:")) {
                    process_gps_data(main_buffer);
                    // 清空缓冲区
                    memset(main_buffer, 0, sizeof(main_buffer));
                }
                
                // 检查是否有健康数据
                if (strstr(main_buffer, "Heart Rate:") && strstr(main_buffer, "SpO2:")) {
                    process_health_data(main_buffer);
                    // 清空缓冲区
                    memset(main_buffer, 0, sizeof(main_buffer));
                }

                // 检查是否有摔倒检测
                if (strstr(main_buffer, "FALL")) {
                    process_fall_data(main_buffer);
                    // 清空缓冲区
                    memset(main_buffer, 0, sizeof(main_buffer));
                }
            }
        }
    }

    // 关闭串口
    close(gps_fd);
    close(ble_fd);
    close(main_fd);

    return 0;
}